<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>shell completions with go cobra library | Chmouel's blog</title><meta name=keywords content><meta name=description content="It always bugging me every time I press the [TAB] key in my shell trying to get a completion to a binary and nothing happen.
Not being super smart I usually press that [TAB] key many times always hopeful that maybe the seventh times it will magically output a completion as expected.
Alas magic isn&rsquo;t a computer function and if a user or a cli author didn&rsquo;t offer a completion function, nothing will ever happen."><meta name=author content><link rel=canonical href=https://blog.chmouel.com/posts/cobra-completions/><link crossorigin=anonymous href=/assets/css/stylesheet.9e486942e3e80b89dff7d0f59b9b383012cb07a9852441596bc21b3168df44a8.css integrity="sha256-nkhpQuPoC4nf99D1m5s4MBLLB6mFJEFZa8IbMWjfRKg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.chmouel.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmouel.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmouel.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmouel.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmouel.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="shell completions with go cobra library"><meta property="og:description" content="It always bugging me every time I press the [TAB] key in my shell trying to get a completion to a binary and nothing happen.
Not being super smart I usually press that [TAB] key many times always hopeful that maybe the seventh times it will magically output a completion as expected.
Alas magic isn&rsquo;t a computer function and if a user or a cli author didn&rsquo;t offer a completion function, nothing will ever happen."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chmouel.com/posts/cobra-completions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-22T09:00:56+02:00"><meta property="article:modified_time" content="2022-11-22T09:00:56+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="shell completions with go cobra library"><meta name=twitter:description content="It always bugging me every time I press the [TAB] key in my shell trying to get a completion to a binary and nothing happen.
Not being super smart I usually press that [TAB] key many times always hopeful that maybe the seventh times it will magically output a completion as expected.
Alas magic isn&rsquo;t a computer function and if a user or a cli author didn&rsquo;t offer a completion function, nothing will ever happen."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmouel.com/posts/"},{"@type":"ListItem","position":2,"name":"shell completions with go cobra library","item":"https://blog.chmouel.com/posts/cobra-completions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"shell completions with go cobra library","name":"shell completions with go cobra library","description":"It always bugging me every time I press the [TAB] key in my shell trying to get a completion to a binary and nothing happen.\nNot being super smart I usually press that [TAB] key many times always hopeful that maybe the seventh times it will magically output a completion as expected.\nAlas magic isn\u0026rsquo;t a computer function and if a user or a cli author didn\u0026rsquo;t offer a completion function, nothing will ever happen.","keywords":[],"articleBody":"It always bugging me every time I press the [TAB] key in my shell trying to get a completion to a binary and nothing happen.\nNot being super smart I usually press that [TAB] key many times always hopeful that maybe the seventh times it will magically output a completion as expected.\nAlas magic isn’t a computer function and if a user or a cli author didn’t offer a completion function, nothing will ever happen.\nWe used to have to write completion function manually. There is a huge collection of completion functions for different binaries for ZSH (zsh has a lot of completion function built-it too) or Bash.\nAll these functions are a good way to get nice completions for the standard Unix binaries.\nOn the non standard one, if you have to make the completion manually yourself and you aren’t a shell ninja then it may be painful. I did this a long time ago for the openshift client when the “oc/osc” cli didn’t offer a builtin completion mechanism.\nThe process was tedious, not just figuring out the right incantation to the zsh completion system but more importantly to keep it in sync it with the binary new features and change of behaviour.\nThankfully most modern CLI libraries provides “built-in” shell completions to make easy for developers to provides completion transparently.\nIn the go word a number of projects are using the Cobra library and here is some examples on how to define the completion for your cli.\nBasics you simply define a new command called completion and output the snippet used for the specific shell directly from the binary like this (full example here):\nfunc Command() *cobra.Command { cmd := \u0026cobra.Command{ Use: \"completion [SHELL]\", Short: \"Prints shell completion scripts\", Long: desc, ValidArgs: []string{\"bash\", \"zsh\", \"fish\", \"powershell\"}, Example: eg, Annotations: map[string]string{ \"commandType\": \"main\", }, Args: cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs), RunE: func(cmd *cobra.Command, args []string) error { switch args[0] { case \"bash\": _ = cmd.Root().GenBashCompletion(cmd.OutOrStdout()) case \"zsh\": _ = cmd.Root().GenZshCompletion(cmd.OutOrStdout()) case \"fish\": _ = cmd.Root().GenFishCompletion(cmd.OutOrStdout(), true) case \"powershell\": _ = cmd.Root().GenPowerShellCompletion(cmd.OutOrStdout()) } return nil }, } return cmd } This will define a new command called completion with the first argument being the target shell and the command will use the cobra library to output the specific completion snippet for that shell.\nHow it works cobra completion is most of the time smart enough to analyze your commands and output the right completion to it.\nWhen for example your cobra command has :\nValidArgs: []string{\"bash\", \"zsh\", \"fish\", \"powershell\"}, It will suggest the args after the completion.\nIt will as well suggest all flags and subcommands to the right command.\nThis will get most of the time the job done for most user who are craving (like myself) for completion.\nAnd for the CLI author, this is easy and simple and no need to do any maintenance, you can simply forget it.\nThe way it works when the user press [TAB] the completion functions as generated for the target shell will ask the binary to complete the command with the hidden command __complete command argument to the binary and the binary itself will output then the completion using cobra library.\nDebugging If you want to debug the completion on how it works you can set the variable BASH_COMP_DEBUG_FILE to a filename and the completion function will output (even on zsh) any query it does to that filename.\nCustom completion Sometime you want to offer your own completion to a specific command.\nTo do so you need to define in your Command a ValidArgsFunction with this signature:\nValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) { outputs := []{\"hello\", \"moto\"} return outputs, cobra.ShellCompDirectiveNoFileComp }, the outputs can be anything dynamics you want. args is the arguments the user provides for example :\ncommand argument he\nyou may want to be smart and provides completion on those arguments (I don’t because it was too annoying)\ncobra.ShellCompDirective return here is a cobra.ShellCompDirectiveNoFileComp but there is other type to mix your argument with for file completions on globing, but there is plenty of other ones, you can see all the definitions in the cobra source here.\nInstallation The best way to tell user to install the completion isn’t to say the much advised :\nsource \u003c(binary completion bash/zsh)\nbecause that command can get quite slow.\nBut instead to actually put it in the completion path, for example on bash while using the bash-completions framework you tell the use to create the directory ~/.local/share/bash-completion and dump the completion there :\n${BINARY_NAME} completion bash \u003e \"${HOME}/.local/share/bash-completion/${BINARY_NAME}\" on ZSH you need to make the user load the completion mechanism in its ~/.zshrc :\nautoload -U compinit; compinit mkdir -p ~/.zsh_completions/ fpath+=(~/.zsh_completions/) and dump the completion in that directory:\n${BINARY_NAME} completion zsh \u003e \"${HOME}/.zsh_completions/_${BINARY_NAME}\" There is many ways to do this differently to different path and for the different shell, I’ll encourage you to do some digging for your target shell and shelll framework.\nPackaging All theses steps can get pretty tedious, the easiest way to consumes your project is to consumes packages. goreleaser makes it very easy.\nHere is some snippet of the yaml to generate the completion with cobra from the aur and brews recipe, I have as well a full and live example here:\nbrews: # homebrew packages - name: ${BINARY_NAME} install: | (bash_completion/\"${BINARY_NAME}\").write output output = Utils.popen_read(\"SHELL=zsh #{bin}/${BINARY_NAME} completion zsh\") (zsh_completion/\"_${BINARY_NAME}\").write output prefix.install_metafiles aurs: # arch package - name: ${BINARY_NAME} [....] package: |- # completions mkdir -p \"${pkgdir}/usr/share/bash-completion/completions/\" mkdir -p \"${pkgdir}/usr/share/zsh/site-functions/\" ./${BINARY_NAME} completion zsh \u003e ${BINARY_NAME}.zsh ./${BINARY_NAME} completion bash \u003e ${BINARY_NAME}.bash install -Dm644 \"${BINARY_NAME}.bash\" \"${pkgdir}/usr/share/bash-completion/completions/${BINARY_NAME}\" install -Dm644 \"${BINARY_NAME}.zsh\" \"${pkgdir}/usr/share/zsh/site-functions/_${BINARY_NAME}\" Other libraries I have successfully added completion to other CLIs using other library.\nwith the urfave/cli library on the gosmee binary. I have defined a completion command here which output this embedded static completion and made sure to enable it at the top level. Installation is about the same as how it works on Cobra. on Rust, using the ubiquitous clap-rs I have snazy using the derive api , it define a completion command using the clap_complete crate and then use the generator to output the snippet Hack the completion by providing your own. A nice hack I figured was to be able to provide extra completion to a binary using the cobra library. For example I wanted to be able to get the pull request number and title when I press tab to the gh binary. The way I did this is to wrap the binary around with a shell script and output the completion I wanted.\nThe shell script on how I did that is available here: https://github.com/chmouel/chmouzies/blob/main/git/gh-completer you simply need to install it in your path as an executable called gh before in the PATH where you real gh is located. There should have been a video here but your browser does not seem to support it. ","wordCount":"1143","inLanguage":"en","datePublished":"2022-11-22T09:00:56+02:00","dateModified":"2022-11-22T09:00:56+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmouel.com/posts/cobra-completions/"},"publisher":{"@type":"Organization","name":"Chmouel's blog","logo":{"@type":"ImageObject","url":"https://blog.chmouel.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chmouel.com/ accesskey=h title="Chmouel's blog (Alt + H)">Chmouel's blog</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://github.com/chmouel/ title=Github><span>Github</span></a></li><li><a href=https://photos.chmouel.com title=Photos><span>Photos</span></a></li><li><a href=https://app.strava.com/athletes/126695 title=Strava><span>Strava</span></a></li><li><a href=https://twitter.com/chmouel title=Twitter><span>Twitter</span></a></li><li><a href=https://redhat.com title=Work><span>Work</span></a></li><li><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>shell completions with go cobra library</h1><div class=post-meta><span title='2022-11-22 09:00:56 +0200 +0200'>November 22, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/chmouel/blog/tree/main/content/posts/cobra-completions/index.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=post-content><p>It always bugging me every time I press the <code>[TAB]</code> key in my shell trying to
get a completion to a binary and nothing happen.</p><p>Not being super smart I usually press that <code>[TAB]</code> key many times always
hopeful that maybe the seventh times it will magically output a completion as expected.</p><p>Alas magic isn&rsquo;t a computer function and if a user or a cli author
didn&rsquo;t offer a completion function, nothing will ever happen.</p><p>We used to have to write completion function manually. There is a huge
collection of completion functions for different binaries for
<a href=https://github.com/zsh-users/zsh-completions>ZSH</a> (zsh has a lot of completion
function built-it too) or
<a href=https://github.com/scop/bash-completion/blob/master/README.md>Bash</a>.</p><p>All these functions are a good way to get nice completions for the standard Unix binaries.</p><p>On the non standard one, if you have to make the completion manually yourself
and you aren&rsquo;t a shell ninja then it may be painful. <a href=https://github.com/chmouel/oh-my-zsh-openshift>I did
this</a> a long time ago for
the openshift client when the &ldquo;oc/osc&rdquo; cli didn&rsquo;t offer a builtin completion
mechanism.</p><p>The process was tedious, not just figuring out the right incantation to
the <a href=https://zsh.sourceforge.io/Doc/Release/Completion-System.html#Completion-System>zsh completion
system</a>
but more importantly to keep it in sync it with the binary new features and
change of behaviour.</p><p>Thankfully most modern CLI libraries provides &ldquo;built-in&rdquo; shell completions to
make easy for developers to provides completion transparently.</p><p>In the <code>go</code> word a number of projects are using the
<a href=https://github.com/spf13/cobra>Cobra</a> library and here is some examples on how
to define the completion for your cli.</p><h2 id=basics>Basics<a hidden class=anchor aria-hidden=true href=#basics>#</a></h2><p>you simply define a new command called <code>completion</code> and output the snippet used
for the specific shell directly from the binary like this (full example
<a href=https://github.com/openshift-pipelines/pipelines-as-code/blob/8b5a2d3dbe6d00462a647abf4bfd95c38b058b5e/pkg/cmd/tknpac/completion/cmd.go#L1>here</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Command</span>() <span style=color:#ff79c6>*</span>cobra.Command {
</span></span><span style=display:flex><span> cmd <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>cobra.Command{
</span></span><span style=display:flex><span>  Use:       <span style=color:#f1fa8c>&#34;completion [SHELL]&#34;</span>,
</span></span><span style=display:flex><span>  Short:     <span style=color:#f1fa8c>&#34;Prints shell completion scripts&#34;</span>,
</span></span><span style=display:flex><span>  Long:      desc,
</span></span><span style=display:flex><span>  ValidArgs: []<span style=color:#8be9fd>string</span>{<span style=color:#f1fa8c>&#34;bash&#34;</span>, <span style=color:#f1fa8c>&#34;zsh&#34;</span>, <span style=color:#f1fa8c>&#34;fish&#34;</span>, <span style=color:#f1fa8c>&#34;powershell&#34;</span>},
</span></span><span style=display:flex><span>  Example:   eg,
</span></span><span style=display:flex><span>  Annotations: <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>string</span>{
</span></span><span style=display:flex><span>   <span style=color:#f1fa8c>&#34;commandType&#34;</span>: <span style=color:#f1fa8c>&#34;main&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  Args: cobra.<span style=color:#50fa7b>MatchAll</span>(cobra.<span style=color:#50fa7b>ExactArgs</span>(<span style=color:#bd93f9>1</span>), cobra.OnlyValidArgs),
</span></span><span style=display:flex><span>  RunE: <span style=color:#8be9fd;font-style:italic>func</span>(cmd <span style=color:#ff79c6>*</span>cobra.Command, args []<span style=color:#8be9fd>string</span>) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>switch</span> args[<span style=color:#bd93f9>0</span>] {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;bash&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenBashCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>())
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;zsh&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenZshCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>())
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;fish&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenFishCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>(), <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;powershell&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenPowerShellCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>())
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#ff79c6>return</span> cmd
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will define a new command called <code>completion</code> with the first argument being
the target shell and the command will use the cobra library to output the
specific completion snippet for that shell.</p><h2 id=how-it-works>How it works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><p>cobra completion is most of the time smart enough to analyze your commands and
output the right completion to it.</p><p>When for example your cobra command has :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>ValidArgs: []string{&#34;bash&#34;, &#34;zsh&#34;, &#34;fish&#34;, &#34;powershell&#34;},
</span></span></code></pre></div><p>It will suggest the args after the completion.</p><p>It will as well suggest all flags and subcommands to the right command.</p><p>This will get most of the time the job done for most user who are craving (like
myself) for completion.</p><p>And for the CLI author, this is easy and simple and no need to do any
maintenance, you can simply forget it.</p><p>The way it works when the user press <code>[TAB]</code> the completion functions as
generated for the target shell will ask the binary to complete the command with
the hidden command <code>__complete command</code> argument to the binary and the binary
itself will output then the completion using cobra library.</p><h2 id=debugging>Debugging<a hidden class=anchor aria-hidden=true href=#debugging>#</a></h2><p>If you want to debug the completion on how it works you can set the variable
<code>BASH_COMP_DEBUG_FILE</code> to a filename and the completion function will output
(even on zsh) any query it does to that filename.</p><h2 id=custom-completion>Custom completion<a hidden class=anchor aria-hidden=true href=#custom-completion>#</a></h2><p>Sometime you want to offer your own completion to a specific command.</p><p>To do so you need to define in your <code>Command</code> a <code>ValidArgsFunction</code> with this signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>ValidArgsFunction: <span style=color:#8be9fd;font-style:italic>func</span>(cmd <span style=color:#ff79c6>*</span>cobra.Command, args []<span style=color:#8be9fd>string</span>, toComplete <span style=color:#8be9fd>string</span>) ([]<span style=color:#8be9fd>string</span>, cobra.ShellCompDirective) {
</span></span><span style=display:flex><span> outputs <span style=color:#ff79c6>:=</span> []{<span style=color:#f1fa8c>&#34;hello&#34;</span>, <span style=color:#f1fa8c>&#34;moto&#34;</span>}
</span></span><span style=display:flex><span> <span style=color:#ff79c6>return</span> outputs, cobra.ShellCompDirectiveNoFileComp
</span></span><span style=display:flex><span>},
</span></span></code></pre></div><p>the <code>outputs</code> can be anything dynamics you want. <code>args</code> is the arguments the user provides for example :</p><p><code>command argument he&lt;TAB></code></p><p>you may want to be smart and provides completion on those arguments (I don&rsquo;t because it was too annoying)</p><p><code>cobra.ShellCompDirective</code> return here is a <code>cobra.ShellCompDirectiveNoFileComp</code>
but there is other type to mix your argument with for file completions on
globing, but there is plenty of other ones, you can see all the definitions in the
cobra source <a href=https://github.com/spf13/cobra/blob/main/completions.go#L54>here</a>.</p><h2 id=installation>Installation<a hidden class=anchor aria-hidden=true href=#installation>#</a></h2><p>The best way to tell user to install the completion isn&rsquo;t to say the much advised :</p><p><code>source &lt;(binary completion bash/zsh)</code></p><p>because that command can get quite slow.</p><p>But instead to actually put it in the completion path, for example on bash
while using the
<a href=https://github.com/scop/bash-completion/blob/master/README.md><code>bash-completions</code></a>
framework you tell the use to create the directory
<code>~/.local/share/bash-completion</code> and dump the completion there :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-console data-lang=console><span style=display:flex><span>$<span style=color:#ff79c6>{</span>BINARY_NAME<span style=color:#ff79c6>}</span> completion bash &gt; <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>HOME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>/.local/share/bash-completion/</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>BINARY_NAME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span></code></pre></div><p>on ZSH you need to make the user load the completion mechanism in its <code>~/.zshrc</code> :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>autoload -U compinit;
</span></span><span style=display:flex><span>compinit
</span></span><span style=display:flex><span>mkdir -p ~/.zsh_completions/
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>fpath</span><span style=color:#ff79c6>+=(</span>~/.zsh_completions/<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><p>and dump the completion in that directory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-console data-lang=console><span style=display:flex><span>$<span style=color:#ff79c6>{</span>BINARY_NAME<span style=color:#ff79c6>}</span> completion zsh &gt; <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>HOME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>/.zsh_completions/_</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>BINARY_NAME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span></code></pre></div><p>There is many ways to do this differently to different path and for the
different shell, I&rsquo;ll encourage you to do some digging for your target shell and
shelll framework.</p><h2 id=packaging>Packaging<a hidden class=anchor aria-hidden=true href=#packaging>#</a></h2><p>All theses steps can get pretty tedious, the easiest way to consumes your
project is to consumes packages. <a href=https://goreleaser.com/>goreleaser</a> makes it
very easy.</p><p>Here is some snippet of the yaml to generate the completion with <code>cobra</code> from
the <code>aur</code> and <code>brews</code> recipe, I have as well a full and <a href=https://github.com/openshift-pipelines/pipelines-as-code/blob/main/.goreleaser.yml>live example
here</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>brews</span>:  <span style=color:#6272a4># homebrew packages</span>
</span></span><span style=display:flex><span> - <span style=color:#ff79c6>name</span>: ${BINARY_NAME}
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>install</span>: |<span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      (bash_completion/&#34;${BINARY_NAME}&#34;).write output
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      output = Utils.popen_read(&#34;SHELL=zsh #{bin}/${BINARY_NAME} completion zsh&#34;)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      (zsh_completion/&#34;_${BINARY_NAME}&#34;).write output
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      prefix.install_metafiles</span>      
</span></span><span style=display:flex><span><span style=color:#ff79c6>aurs</span>: <span style=color:#6272a4># arch package</span>
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>name</span>: ${BINARY_NAME}
</span></span><span style=display:flex><span>[....]
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>package</span>: |-<span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    # completions
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    mkdir -p &#34;${pkgdir}/usr/share/bash-completion/completions/&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    mkdir -p &#34;${pkgdir}/usr/share/zsh/site-functions/&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ./${BINARY_NAME} completion zsh &gt; ${BINARY_NAME}.zsh
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ./${BINARY_NAME} completion bash &gt; ${BINARY_NAME}.bash
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    install -Dm644 &#34;${BINARY_NAME}.bash&#34; &#34;${pkgdir}/usr/share/bash-completion/completions/${BINARY_NAME}&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    install -Dm644 &#34;${BINARY_NAME}.zsh&#34; &#34;${pkgdir}/usr/share/zsh/site-functions/_${BINARY_NAME}&#34;</span>    
</span></span></code></pre></div><h2 id=other-libraries>Other libraries<a hidden class=anchor aria-hidden=true href=#other-libraries>#</a></h2><p>I have successfully added completion to other CLIs using other library.</p><ul><li>with the <a href=https://github.com/urfave/cli>urfave/cli</a> library on the <a href=https://github.com/chmouel/gosmee>gosmee</a>
binary. I have defined a completion command
<a href=https://github.com/chmouel/gosmee/blob/adaa13e318d0a5b81026ed5aaf0e7a983494bb9d/gosmee/app.go#L142>here</a>
which output this <a href=https://github.com/chmouel/gosmee/blob/adaa13e318d0a5b81026ed5aaf0e7a983494bb9d/gosmee/app.go#L15-L19>embedded static
completion</a>
and made sure to <a href=https://github.com/chmouel/gosmee/blob/main/gosmee/app.go#L29>enable
it</a> at the top
level. Installation is about the same as how it works on Cobra.</li><li>on Rust, using the ubiquitous <a href>clap-rs</a> I have <a href=github.com/chmouel/snazy>snazy</a> using the <a href=https://docs.rs/clap/latest/clap/_derive/index.html>derive api</a> , it define a <code>completion</code> <a href=https://github.com/chmouel/snazy/blob/main/src/cli.rs#L35-L37>command</a> using the <a href=https://docs.rs/clap_complete/latest/clap_complete/>clap_complete crate</a> and then use the <a href=https://github.com/chmouel/snazy/blob/0df6b95433eb5d5564ea9161677ed5325bb809db/src/cli.rs#LL162>generator</a> to output the <a href=https://github.com/chmouel/snazy/blob/0df6b95433eb5d5564ea9161677ed5325bb809db/src/cli.rs#L155-L157>snippet</a></li></ul><h2 id=hack-the-completion-by-providing-your-own>Hack the completion by providing your own.<a hidden class=anchor aria-hidden=true href=#hack-the-completion-by-providing-your-own>#</a></h2><p>A nice hack I figured was to be able to provide extra completion to a binary using the cobra library.
For example I wanted to be able to get the pull request number and title when I press tab to the <a href=https://github.com/cli/cli/>gh</a> binary.
The way I did this is to wrap the binary around with a shell script and output the completion I wanted.</p><p>The shell script on how I did that is available here:
<a href=https://github.com/chmouel/chmouzies/blob/main/git/gh-completer>https://github.com/chmouel/chmouzies/blob/main/git/gh-completer</a> you simply need
to install it in your path as an executable called <code>gh</code> before in the PATH where
you real <code>gh</code> is located.
<video height=600 width=800 class=video-shortcode preload=auto controls>
<source src=shellcompletions.mov type=video/webm>There should have been a video here but your browser does not seem
to support it.</video></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.chmouel.com/>Chmouel's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>