<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>shell completions with go cobra library | Chmouel's blog</title>
<meta name=keywords content><meta name=description content="Every time I press the [TAB] key in my shell, it bothers me that nothing happens.
I&rsquo;m not very smart, so I often press the [TAB] key multiple times, hoping that maybe the seventh time will magically produce the completion that I expect.
However, magic is not a computer function, and if a user or command line interface (CLI) author has not provided a completion function, nothing will ever happen."><meta name=author content><link rel=canonical href=https://blog.chmouel.com/posts/cobra-completions/><link crossorigin=anonymous href=/assets/css/stylesheet.ab393ed2c603998a7d6b9e8eda123466b9d201fa71eb05cebc80d3db7d812d18.css integrity="sha256-qzk+0sYDmYp9a56O2hI0ZrnSAfpx6wXOvIDT232BLRg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.chmouel.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmouel.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmouel.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmouel.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmouel.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="shell completions with go cobra library"><meta property="og:description" content="Every time I press the [TAB] key in my shell, it bothers me that nothing happens.
I&rsquo;m not very smart, so I often press the [TAB] key multiple times, hoping that maybe the seventh time will magically produce the completion that I expect.
However, magic is not a computer function, and if a user or command line interface (CLI) author has not provided a completion function, nothing will ever happen."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chmouel.com/posts/cobra-completions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-22T09:00:56+02:00"><meta property="article:modified_time" content="2022-11-22T09:00:56+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="shell completions with go cobra library"><meta name=twitter:description content="Every time I press the [TAB] key in my shell, it bothers me that nothing happens.
I&rsquo;m not very smart, so I often press the [TAB] key multiple times, hoping that maybe the seventh time will magically produce the completion that I expect.
However, magic is not a computer function, and if a user or command line interface (CLI) author has not provided a completion function, nothing will ever happen."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmouel.com/posts/"},{"@type":"ListItem","position":2,"name":"shell completions with go cobra library","item":"https://blog.chmouel.com/posts/cobra-completions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"shell completions with go cobra library","name":"shell completions with go cobra library","description":"Every time I press the [TAB] key in my shell, it bothers me that nothing happens.\nI\u0026rsquo;m not very smart, so I often press the [TAB] key multiple times, hoping that maybe the seventh time will magically produce the completion that I expect.\nHowever, magic is not a computer function, and if a user or command line interface (CLI) author has not provided a completion function, nothing will ever happen.","keywords":[],"articleBody":"Every time I press the [TAB] key in my shell, it bothers me that nothing happens.\nI’m not very smart, so I often press the [TAB] key multiple times, hoping that maybe the seventh time will magically produce the completion that I expect.\nHowever, magic is not a computer function, and if a user or command line interface (CLI) author has not provided a completion function, nothing will ever happen.\nThis used to be a manual task, Users has contributed a huge collection of completion functions for multiple binaries. Here is some completions for ZSH (zsh has a large number of builtins completion too) and here is some for Bash.\nAll these functions are a good way to get nice completions for most popular Unix binaries.\nProviding shell completion when you are not an expert in shell scripting, can be a frustrating and difficult process. For example, I previously created zsh completions manually for the openshift client, but it was a tedious and time-consuming task. Just the process of having to keep it updated with the new flags and arguments could get very frustrating.\nAdvanced shell scripting can be difficult to learn, especially when you have to work with multiple shell environments, such as bash, zsh, powershell, and fish. This can greatly increase the complexity and difficulty of the task.\nThankfully, most modern CLI libraries now offer built-in shell completion mechanisms, which make it easier for developers to provide completion functionality for their programs.\nFor the purposes of this article, we will focus on the Go programming language and one of its most popular libraries for command line interface (CLI) parsing, Cobra.\nBasics you simply define a new command called completion and output the snippet used for the specific shell directly from the binary like this (full example here):\nfunc Command() *cobra.Command { cmd := \u0026cobra.Command{ Use: \"completion [SHELL]\", Short: \"Prints shell completion scripts\", Long: desc, ValidArgs: []string{\"bash\", \"zsh\", \"fish\", \"powershell\"}, Example: eg, Annotations: map[string]string{ \"commandType\": \"main\", }, Args: cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs), RunE: func(cmd *cobra.Command, args []string) error { switch args[0] { case \"bash\": _ = cmd.Root().GenBashCompletion(cmd.OutOrStdout()) case \"zsh\": _ = cmd.Root().GenZshCompletion(cmd.OutOrStdout()) case \"fish\": _ = cmd.Root().GenFishCompletion(cmd.OutOrStdout(), true) case \"powershell\": _ = cmd.Root().GenPowerShellCompletion(cmd.OutOrStdout()) } return nil }, } return cmd } This will define a new command called completion with the first argument being the target shell and the command will use the cobra library to output the specific completion snippet for that shell.\nHow it works cobra completion is most of the time smart enough to analyze your commands and output the right completion to it.\nWhen for example your cobra command has :\nValidArgs: []string{\"bash\", \"zsh\", \"fish\", \"powershell\"}, It will suggest the args after the completion.\nIt will as well suggest all flags and subcommands to the right command.\nThis will get most of the time the job done for most user who are craving (like myself) for completion.\nAnd for the CLI author, this is easy and simple and no need to do any maintenance, you can simply forget it.\nThe way it works when the user press [TAB] the completion functions as generated for the target shell will ask the binary to complete the command with the hidden command __complete command argument to the binary and the binary itself will output then the completion using cobra library.\nDebugging If you want to debug the completion on how it works you can set the variable BASH_COMP_DEBUG_FILE to a filename and the completion function will output (even on zsh) any query it does to that filename.\nCustom completion Sometime you want to offer your own completion to a specific command.\nTo do so you need to define in your Command a ValidArgsFunction with this signature:\nValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) { outputs := []{\"hello\", \"moto\"} return outputs, cobra.ShellCompDirectiveNoFileComp }, the outputs can be anything dynamics you want. args is the arguments the user provides for example :\ncommand argument he\nyou may want to be smart and provides completion on those arguments (I don’t because it was too annoying)\ncobra.ShellCompDirective return here is a cobra.ShellCompDirectiveNoFileComp but there is other type to mix your argument with for file completions on globing, but there is plenty of other ones, you can see all the definitions in the cobra source here.\nInstallation The best way to tell user to install the completion isn’t to say the much advised :\nsource \u003c(binary completion bash/zsh)\nbecause that command can get quite slow.\nBut instead to actually put it in the completion path, for example on bash while using the bash-completions framework you tell the use to create the directory ~/.local/share/bash-completion and dump the completion there :\n${BINARY_NAME} completion bash \u003e \"${HOME}/.local/share/bash-completion/${BINARY_NAME}\" on ZSH you need to make the user load the completion mechanism in its ~/.zshrc :\nautoload -U compinit; compinit mkdir -p ~/.zsh_completions/ fpath+=(~/.zsh_completions/) and dump the completion in that directory:\n${BINARY_NAME} completion zsh \u003e \"${HOME}/.zsh_completions/_${BINARY_NAME}\" There is many ways to do this differently to different path and for the different shell, I’ll encourage you to do some digging for your target shell and shelll framework.\nPackaging All theses steps can get pretty tedious, the easiest way to consumes your project is to consumes packages. goreleaser makes it very easy.\nHere is some snippet of the yaml to generate the completion with cobra from the aur and brews recipe, I have as well a full and live example here:\nbrews: # homebrew packages - name: ${BINARY_NAME} install: | (bash_completion/\"${BINARY_NAME}\").write output output = Utils.popen_read(\"SHELL=zsh #{bin}/${BINARY_NAME} completion zsh\") (zsh_completion/\"_${BINARY_NAME}\").write output prefix.install_metafiles aurs: # arch package - name: ${BINARY_NAME} [....] package: |- # completions mkdir -p \"${pkgdir}/usr/share/bash-completion/completions/\" mkdir -p \"${pkgdir}/usr/share/zsh/site-functions/\" ./${BINARY_NAME} completion zsh \u003e ${BINARY_NAME}.zsh ./${BINARY_NAME} completion bash \u003e ${BINARY_NAME}.bash install -Dm644 \"${BINARY_NAME}.bash\" \"${pkgdir}/usr/share/bash-completion/completions/${BINARY_NAME}\" install -Dm644 \"${BINARY_NAME}.zsh\" \"${pkgdir}/usr/share/zsh/site-functions/_${BINARY_NAME}\" Other libraries I have successfully added completion to other CLIs using other library.\nwith the urfave/cli library on the gosmee binary. I have defined a completion command here which output this embedded static completion and made sure to enable it at the top level. Installation is about the same as how it works on Cobra. on Rust, using the ubiquitous clap-rs I have snazy using the derive api , it define a completion command using the clap_complete crate and then use the generator to output the snippet Hack the completion by providing your own. A nice hack I figured was to be able to provide extra completion to a binary using the cobra library. For example I wanted to be able to get the pull request number and title when I press tab to the gh binary. The way I did this is to wrap the binary around with a shell script and output the completion I wanted.\nThe shell script on how I did that is available here: https://github.com/chmouel/chmouzies/blob/main/git/gh-completer you simply need to install it in your path as an executable called gh before in the PATH where you real gh is located. There should have been a video here but your browser does not seem to support it. ","wordCount":"1166","inLanguage":"en","datePublished":"2022-11-22T09:00:56+02:00","dateModified":"2022-11-22T09:00:56+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmouel.com/posts/cobra-completions/"},"publisher":{"@type":"Organization","name":"Chmouel's blog","logo":{"@type":"ImageObject","url":"https://blog.chmouel.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chmouel.com/ accesskey=h title="Chmouel's blog (Alt + H)">Chmouel's blog</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://redhat.com title=briefcase><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M184 48H328c4.4.0 8 3.6 8 8V96H176V56c0-4.4 3.6-8 8-8zm-56 8V96H64C28.7 96 0 124.7.0 160v96H192 320 512V160c0-35.3-28.7-64-64-64H384V56c0-30.9-25.1-56-56-56H184c-30.9.0-56 25.1-56 56zM512 288H320v32c0 17.7-14.3 32-32 32H224c-17.7.0-32-14.3-32-32V288H0V416c0 35.3 28.7 64 64 64H448c35.3.0 64-28.7 64-64V288z"/></svg><span></span></a></li><li><a href=https://photos.chmouel.com title=camera><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M149.1 64.8 138.7 96H64C28.7 96 0 124.7.0 160V416c0 35.3 28.7 64 64 64H448c35.3.0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H373.3L362.9 64.8C356.4 45.2 338.1 32 317.4 32H194.6c-20.7.0-39 13.2-45.5 32.8zM256 192a96 96 0 110 192 96 96 0 110-192z"/></svg><span></span></a></li><li><a href=https://github.com/chmouel/ title=GitHub><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><span></span></a></li><li><a href=https://fosstodon.org/@chmouel title=Mastodon><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg><span></span></a></li><li><a href=https://app.strava.com/athletes/126695 title=Strava><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M158.4.0 7 292h89.2l62.2-116.1L220.1 292h88.5zm150.2 292-43.9 88.2-44.6-88.2h-67.6l112.2 220 111.5-220z"/></svg><span></span></a></li><li><a href=https://twitter.com/chmouel title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg><span></span></a></li><li><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>shell completions with go cobra library</h1><div class=post-meta><span title='2022-11-22 09:00:56 +0200 +0200'>November 22, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/chmouel/blog/tree/main/content/posts/cobra-completions/index.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=post-content><p>Every time I press the <code>[TAB]</code> key in my shell, it bothers me that nothing happens.</p><p>I&rsquo;m not very smart, so I often press the <code>[TAB]</code> key multiple times, hoping that
maybe the seventh time will magically produce the completion that I expect.</p><p>However, magic is not a computer function, and if a user or command line
interface (CLI) author has not provided a completion function, nothing will ever
happen.</p><p>This used to be a manual task, Users has contributed a huge collection of
completion functions for multiple binaries. Here is some completions for
<a href=https://github.com/zsh-users/zsh-completions>ZSH</a> (zsh has a large number of
builtins completion too) and here is some for
<a href=https://github.com/scop/bash-completion/blob/master/README.md>Bash</a>.</p><p>All these functions are a good way to get nice completions for most popular Unix
binaries.</p><p>Providing shell completion when you are not an expert in shell scripting, can be
a frustrating and difficult process. For example, I
previously created <a href=https://github.com/chmouel/oh-my-zsh-openshift>zsh completions</a> manually
for the openshift client, but it was a tedious and time-consuming task. Just the process of
having to keep it updated with the new flags and arguments could get very frustrating.</p><p>Advanced shell scripting can be difficult to learn, especially when you have to
work with multiple shell environments, such as bash, zsh, powershell, and
fish. This can greatly increase the complexity and difficulty of the task.</p><p>Thankfully, most modern CLI libraries now offer built-in shell completion
mechanisms, which make it easier for developers to provide completion
functionality for their programs.</p><p>For the purposes of this article, we will focus on the Go programming language
and one of its most popular libraries for command line interface (CLI) parsing,
<a href=https://github.com/spf13/cobra>Cobra</a>.</p><h2 id=basics>Basics<a hidden class=anchor aria-hidden=true href=#basics>#</a></h2><p>you simply define a new command called <code>completion</code> and output the snippet used
for the specific shell directly from the binary like this (full example
<a href=https://github.com/openshift-pipelines/pipelines-as-code/blob/8b5a2d3dbe6d00462a647abf4bfd95c38b058b5e/pkg/cmd/tknpac/completion/cmd.go#L1>here</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>Command</span>() <span style=color:#ff79c6>*</span>cobra.Command {
</span></span><span style=display:flex><span> cmd <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>cobra.Command{
</span></span><span style=display:flex><span>  Use:       <span style=color:#f1fa8c>&#34;completion [SHELL]&#34;</span>,
</span></span><span style=display:flex><span>  Short:     <span style=color:#f1fa8c>&#34;Prints shell completion scripts&#34;</span>,
</span></span><span style=display:flex><span>  Long:      desc,
</span></span><span style=display:flex><span>  ValidArgs: []<span style=color:#8be9fd>string</span>{<span style=color:#f1fa8c>&#34;bash&#34;</span>, <span style=color:#f1fa8c>&#34;zsh&#34;</span>, <span style=color:#f1fa8c>&#34;fish&#34;</span>, <span style=color:#f1fa8c>&#34;powershell&#34;</span>},
</span></span><span style=display:flex><span>  Example:   eg,
</span></span><span style=display:flex><span>  Annotations: <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>string</span>{
</span></span><span style=display:flex><span>   <span style=color:#f1fa8c>&#34;commandType&#34;</span>: <span style=color:#f1fa8c>&#34;main&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  Args: cobra.<span style=color:#50fa7b>MatchAll</span>(cobra.<span style=color:#50fa7b>ExactArgs</span>(<span style=color:#bd93f9>1</span>), cobra.OnlyValidArgs),
</span></span><span style=display:flex><span>  RunE: <span style=color:#8be9fd;font-style:italic>func</span>(cmd <span style=color:#ff79c6>*</span>cobra.Command, args []<span style=color:#8be9fd>string</span>) <span style=color:#8be9fd>error</span> {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>switch</span> args[<span style=color:#bd93f9>0</span>] {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;bash&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenBashCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>())
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;zsh&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenZshCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>())
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;fish&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenFishCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>(), <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>case</span> <span style=color:#f1fa8c>&#34;powershell&#34;</span>:
</span></span><span style=display:flex><span>    _ = cmd.<span style=color:#50fa7b>Root</span>().<span style=color:#50fa7b>GenPowerShellCompletion</span>(cmd.<span style=color:#50fa7b>OutOrStdout</span>())
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#ff79c6>return</span> cmd
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will define a new command called <code>completion</code> with the first argument being
the target shell and the command will use the cobra library to output the
specific completion snippet for that shell.</p><h2 id=how-it-works>How it works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><p>cobra completion is most of the time smart enough to analyze your commands and
output the right completion to it.</p><p>When for example your cobra command has :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>ValidArgs: []string{&#34;bash&#34;, &#34;zsh&#34;, &#34;fish&#34;, &#34;powershell&#34;},
</span></span></code></pre></div><p>It will suggest the args after the completion.</p><p>It will as well suggest all flags and subcommands to the right command.</p><p>This will get most of the time the job done for most user who are craving (like
myself) for completion.</p><p>And for the CLI author, this is easy and simple and no need to do any
maintenance, you can simply forget it.</p><p>The way it works when the user press <code>[TAB]</code> the completion functions as
generated for the target shell will ask the binary to complete the command with
the hidden command <code>__complete command</code> argument to the binary and the binary
itself will output then the completion using cobra library.</p><h2 id=debugging>Debugging<a hidden class=anchor aria-hidden=true href=#debugging>#</a></h2><p>If you want to debug the completion on how it works you can set the variable
<code>BASH_COMP_DEBUG_FILE</code> to a filename and the completion function will output
(even on zsh) any query it does to that filename.</p><h2 id=custom-completion>Custom completion<a hidden class=anchor aria-hidden=true href=#custom-completion>#</a></h2><p>Sometime you want to offer your own completion to a specific command.</p><p>To do so you need to define in your <code>Command</code> a <code>ValidArgsFunction</code> with this signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>ValidArgsFunction: <span style=color:#8be9fd;font-style:italic>func</span>(cmd <span style=color:#ff79c6>*</span>cobra.Command, args []<span style=color:#8be9fd>string</span>, toComplete <span style=color:#8be9fd>string</span>) ([]<span style=color:#8be9fd>string</span>, cobra.ShellCompDirective) {
</span></span><span style=display:flex><span> outputs <span style=color:#ff79c6>:=</span> []{<span style=color:#f1fa8c>&#34;hello&#34;</span>, <span style=color:#f1fa8c>&#34;moto&#34;</span>}
</span></span><span style=display:flex><span> <span style=color:#ff79c6>return</span> outputs, cobra.ShellCompDirectiveNoFileComp
</span></span><span style=display:flex><span>},
</span></span></code></pre></div><p>the <code>outputs</code> can be anything dynamics you want. <code>args</code> is the arguments the user provides for example :</p><p><code>command argument he&lt;TAB></code></p><p>you may want to be smart and provides completion on those arguments (I don&rsquo;t because it was too annoying)</p><p><code>cobra.ShellCompDirective</code> return here is a <code>cobra.ShellCompDirectiveNoFileComp</code>
but there is other type to mix your argument with for file completions on
globing, but there is plenty of other ones, you can see all the definitions in the
cobra source <a href=https://github.com/spf13/cobra/blob/main/completions.go#L54>here</a>.</p><h2 id=installation>Installation<a hidden class=anchor aria-hidden=true href=#installation>#</a></h2><p>The best way to tell user to install the completion isn&rsquo;t to say the much advised :</p><p><code>source &lt;(binary completion bash/zsh)</code></p><p>because that command can get quite slow.</p><p>But instead to actually put it in the completion path, for example on bash
while using the
<a href=https://github.com/scop/bash-completion/blob/master/README.md><code>bash-completions</code></a>
framework you tell the use to create the directory
<code>~/.local/share/bash-completion</code> and dump the completion there :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-console data-lang=console><span style=display:flex><span>$<span style=color:#ff79c6>{</span>BINARY_NAME<span style=color:#ff79c6>}</span> completion bash &gt; <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>HOME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>/.local/share/bash-completion/</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>BINARY_NAME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span></code></pre></div><p>on ZSH you need to make the user load the completion mechanism in its <code>~/.zshrc</code> :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>autoload -U compinit;
</span></span><span style=display:flex><span>compinit
</span></span><span style=display:flex><span>mkdir -p ~/.zsh_completions/
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>fpath</span><span style=color:#ff79c6>+=(</span>~/.zsh_completions/<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><p>and dump the completion in that directory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-console data-lang=console><span style=display:flex><span>$<span style=color:#ff79c6>{</span>BINARY_NAME<span style=color:#ff79c6>}</span> completion zsh &gt; <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>HOME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>/.zsh_completions/_</span><span style=color:#f1fa8c>${</span><span style=color:#8be9fd;font-style:italic>BINARY_NAME</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>&#34;</span>
</span></span></code></pre></div><p>There is many ways to do this differently to different path and for the
different shell, I&rsquo;ll encourage you to do some digging for your target shell and
shelll framework.</p><h2 id=packaging>Packaging<a hidden class=anchor aria-hidden=true href=#packaging>#</a></h2><p>All theses steps can get pretty tedious, the easiest way to consumes your
project is to consumes packages. <a href=https://goreleaser.com/>goreleaser</a> makes it
very easy.</p><p>Here is some snippet of the yaml to generate the completion with <code>cobra</code> from
the <code>aur</code> and <code>brews</code> recipe, I have as well a full and <a href=https://github.com/openshift-pipelines/pipelines-as-code/blob/main/.goreleaser.yml>live example
here</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ff79c6>brews</span>:  <span style=color:#6272a4># homebrew packages</span>
</span></span><span style=display:flex><span> - <span style=color:#ff79c6>name</span>: ${BINARY_NAME}
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>install</span>: |<span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      (bash_completion/&#34;${BINARY_NAME}&#34;).write output
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      output = Utils.popen_read(&#34;SHELL=zsh #{bin}/${BINARY_NAME} completion zsh&#34;)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      (zsh_completion/&#34;_${BINARY_NAME}&#34;).write output
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>      prefix.install_metafiles</span>      
</span></span><span style=display:flex><span><span style=color:#ff79c6>aurs</span>: <span style=color:#6272a4># arch package</span>
</span></span><span style=display:flex><span>- <span style=color:#ff79c6>name</span>: ${BINARY_NAME}
</span></span><span style=display:flex><span>[....]
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>package</span>: |-<span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    # completions
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    mkdir -p &#34;${pkgdir}/usr/share/bash-completion/completions/&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    mkdir -p &#34;${pkgdir}/usr/share/zsh/site-functions/&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ./${BINARY_NAME} completion zsh &gt; ${BINARY_NAME}.zsh
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    ./${BINARY_NAME} completion bash &gt; ${BINARY_NAME}.bash
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    install -Dm644 &#34;${BINARY_NAME}.bash&#34; &#34;${pkgdir}/usr/share/bash-completion/completions/${BINARY_NAME}&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    install -Dm644 &#34;${BINARY_NAME}.zsh&#34; &#34;${pkgdir}/usr/share/zsh/site-functions/_${BINARY_NAME}&#34;</span>    
</span></span></code></pre></div><h2 id=other-libraries>Other libraries<a hidden class=anchor aria-hidden=true href=#other-libraries>#</a></h2><p>I have successfully added completion to other CLIs using other library.</p><ul><li>with the <a href=https://github.com/urfave/cli>urfave/cli</a> library on the <a href=https://github.com/chmouel/gosmee>gosmee</a>
binary. I have defined a completion command
<a href=https://github.com/chmouel/gosmee/blob/adaa13e318d0a5b81026ed5aaf0e7a983494bb9d/gosmee/app.go#L142>here</a>
which output this <a href=https://github.com/chmouel/gosmee/blob/adaa13e318d0a5b81026ed5aaf0e7a983494bb9d/gosmee/app.go#L15-L19>embedded static
completion</a>
and made sure to <a href=https://github.com/chmouel/gosmee/blob/main/gosmee/app.go#L29>enable
it</a> at the top
level. Installation is about the same as how it works on Cobra.</li><li>on Rust, using the ubiquitous <a href>clap-rs</a> I have <a href=github.com/chmouel/snazy>snazy</a> using the <a href=https://docs.rs/clap/latest/clap/_derive/index.html>derive api</a> , it define a <code>completion</code> <a href=https://github.com/chmouel/snazy/blob/main/src/cli.rs#L35-L37>command</a> using the <a href=https://docs.rs/clap_complete/latest/clap_complete/>clap_complete crate</a> and then use the <a href=https://github.com/chmouel/snazy/blob/0df6b95433eb5d5564ea9161677ed5325bb809db/src/cli.rs#LL162>generator</a> to output the <a href=https://github.com/chmouel/snazy/blob/0df6b95433eb5d5564ea9161677ed5325bb809db/src/cli.rs#L155-L157>snippet</a></li></ul><h2 id=hack-the-completion-by-providing-your-own>Hack the completion by providing your own.<a hidden class=anchor aria-hidden=true href=#hack-the-completion-by-providing-your-own>#</a></h2><p>A nice hack I figured was to be able to provide extra completion to a binary using the cobra library.
For example I wanted to be able to get the pull request number and title when I press tab to the <a href=https://github.com/cli/cli/>gh</a> binary.
The way I did this is to wrap the binary around with a shell script and output the completion I wanted.</p><p>The shell script on how I did that is available here:
<a href=https://github.com/chmouel/chmouzies/blob/main/git/gh-completer>https://github.com/chmouel/chmouzies/blob/main/git/gh-completer</a> you simply need
to install it in your path as an executable called <code>gh</code> before in the PATH where
you real <code>gh</code> is located.
<video height=600 width=800 class=video-shortcode preload=auto controls>
<source src=shellcompletions.mov type=video/webm>There should have been a video here but your browser does not seem
to support it.</video></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chmouel.com/>Chmouel's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>