<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Error chaining with Rust and Go | Chmouel's blog</title>
<meta name=keywords content><meta name=description content="I was talking with a colleague about Rust and we were wondering (since we are both learning the language) how error handling compares to Go.
Chaining error in Go Go&rsquo;s best practice when you want to chain multiple errors is to &ldquo;wrap&rdquo; them.
For example let&rsquo;s say you have this function returning an error:
func do_something() err { value := &#34;value&#34; if value != &#34;expected&#34; { return fmt.Errorf(&#34;this was not expected&#34;) } } when we call the function do_something() from another function, we want to add context to it and to do so we will wrap it around it with the &ldquo;%w&rdquo; directive:"><meta name=author content><link rel=canonical href=https://blog.chmouel.com/posts/rust-errorhandling/><link crossorigin=anonymous href=/assets/css/stylesheet.060b881d8893742854d02a3a291c4a2f70a6d0c12d733e455f6ceb190dfe5c6e.css integrity="sha256-BguIHYiTdChU0Co6KRxKL3Cm0MEtcz5FX2zrGQ3+XG4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.chmouel.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmouel.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmouel.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmouel.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmouel.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Error chaining with Rust and Go"><meta property="og:description" content="I was talking with a colleague about Rust and we were wondering (since we are both learning the language) how error handling compares to Go.
Chaining error in Go Go&rsquo;s best practice when you want to chain multiple errors is to &ldquo;wrap&rdquo; them.
For example let&rsquo;s say you have this function returning an error:
func do_something() err { value := &#34;value&#34; if value != &#34;expected&#34; { return fmt.Errorf(&#34;this was not expected&#34;) } } when we call the function do_something() from another function, we want to add context to it and to do so we will wrap it around it with the &ldquo;%w&rdquo; directive:"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.chmouel.com/posts/rust-errorhandling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-20T09:54:31+02:00"><meta property="article:modified_time" content="2022-05-20T09:54:31+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Error chaining with Rust and Go"><meta name=twitter:description content="I was talking with a colleague about Rust and we were wondering (since we are both learning the language) how error handling compares to Go.
Chaining error in Go Go&rsquo;s best practice when you want to chain multiple errors is to &ldquo;wrap&rdquo; them.
For example let&rsquo;s say you have this function returning an error:
func do_something() err { value := &#34;value&#34; if value != &#34;expected&#34; { return fmt.Errorf(&#34;this was not expected&#34;) } } when we call the function do_something() from another function, we want to add context to it and to do so we will wrap it around it with the &ldquo;%w&rdquo; directive:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmouel.com/posts/"},{"@type":"ListItem","position":2,"name":"Error chaining with Rust and Go","item":"https://blog.chmouel.com/posts/rust-errorhandling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Error chaining with Rust and Go","name":"Error chaining with Rust and Go","description":"I was talking with a colleague about Rust and we were wondering (since we are both learning the language) how error handling compares to Go.\nChaining error in Go Go\u0026rsquo;s best practice when you want to chain multiple errors is to \u0026ldquo;wrap\u0026rdquo; them.\nFor example let\u0026rsquo;s say you have this function returning an error:\nfunc do_something() err { value := \u0026#34;value\u0026#34; if value != \u0026#34;expected\u0026#34; { return fmt.Errorf(\u0026#34;this was not expected\u0026#34;) } } when we call the function do_something() from another function, we want to add context to it and to do so we will wrap it around it with the \u0026ldquo;%w\u0026rdquo; directive:","keywords":[],"articleBody":"I was talking with a colleague about Rust and we were wondering (since we are both learning the language) how error handling compares to Go.\nChaining error in Go Go’s best practice when you want to chain multiple errors is to “wrap” them.\nFor example let’s say you have this function returning an error:\nfunc do_something() err { value := \"value\" if value != \"expected\" { return fmt.Errorf(\"this was not expected\") } } when we call the function do_something() from another function, we want to add context to it and to do so we will wrap it around it with the “%w” directive:\nfn start_doing_something() err { err := do_something() if err != nil { return fmt.Errorf(\"I got an error while trying to do something: %w\", err) } } Error chaining in Rust So now how do we do this in Rust?\nIt does not seems there is any built-in way to do this but you can use the vastly popular crates called anyhow for it.\nIn this case it’s not called wrapping but context (which is a confusing overused term imho) and here is an example :\nuse anyhow::Context; #[derive(thiserror::Error, Debug)] pub enum MyErr { #[error(\"This is the first error\")] FirstError, #[error(\"This is the middle error\")] MidError, #[error(\"This is the final error\")] FinalError, } fn first() -\u003e anyhow::Result\u003c(), MyErr\u003e { Err(MyErr::FirstError) } fn second() -\u003e anyhow::Result\u003c(), anyhow::Error\u003e { first().context(MyErr::MidError) } fn finally() -\u003e anyhow::Result\u003c(), anyhow::Error\u003e { second().context(MyErr::FinalError) } fn main() -\u003e anyhow::Result\u003c()\u003e { finally()?; Ok(()) } We first make our own enum of custom errors. The enum has a derive on another crates called thiserror. This crates allows you to have human friendly error message without having to do too much work for it.\nstarting from the bottom on the main function we return and “Box” all our errors with anyhow::Results this will get all error to it.\nWe call the finally function with the “?” operator at the end. It’s a shorthand to say :\nif it’s Ok, then yeah please go on and continue do your work. if it’s not then return the error. from the finally function we call another function called second, they are both adding a context to the error to let the user know where this comes from. This only happen if we are erroring. If we were Ok() we would not get any error. The final output will looks like this:\n% cargo run -q Error: This is the final error Caused by: 0: This is the middle error 1: This is the first error with the help of anyhow and thiserror we are nicely showing the chain of errors and what caused it.\nMy humble comparaison between Go and Rust error chaining The go way is definitely more idiomatic and much easier to write and understand than the the rust way. However the Rust way is more elegant and I feel in the long term will be more robust if we have to do some refactoring.\n","wordCount":"495","inLanguage":"en","datePublished":"2022-05-20T09:54:31+02:00","dateModified":"2022-05-20T09:54:31+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmouel.com/posts/rust-errorhandling/"},"publisher":{"@type":"Organization","name":"Chmouel's blog","logo":{"@type":"ImageObject","url":"https://blog.chmouel.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chmouel.com/ accesskey=h title="Chmouel's blog (Alt + H)">Chmouel's blog</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://github.com/chmouel/ title=GitHub><span>GitHub</span></a></li><li><a href=https://fosstodon.org/@chmouel title=Mastodon><span>Mastodon</span></a></li><li><a href=https://photos.chmouel.com title=Photos><span>Photos</span></a></li><li><a href=https://app.strava.com/athletes/126695 title=Strava><span>Strava</span></a></li><li><a href=https://twitter.com/chmouel title=Twitter><span>Twitter</span></a></li><li><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Error chaining with Rust and Go</h1><div class=post-meta><span title='2022-05-20 09:54:31 +0200 +0200'>May 20, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/chmouel/blog/tree/main/content/posts/rust-errorhandling.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=post-content><p>I was talking with a <a href=https://www.sebastien-han.fr/blog/>colleague</a> about Rust
and we were wondering (since we are both learning the language) how error
handling compares to Go.</p><h2 id=chaining-error-in-go>Chaining error in Go<a hidden class=anchor aria-hidden=true href=#chaining-error-in-go>#</a></h2><p>Go&rsquo;s best practice when you want to chain multiple errors is to &ldquo;wrap&rdquo; them.</p><p>For example let&rsquo;s say you have this function returning an error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>do_something</span>() err {
</span></span><span style=display:flex><span> value <span style=color:#ff79c6>:=</span> <span style=color:#f1fa8c>&#34;value&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> value <span style=color:#ff79c6>!=</span> <span style=color:#f1fa8c>&#34;expected&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;this was not expected&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>when we call the function <code>do_something()</code> from another function, we want to
add context to it and to do so we will wrap it around it with the &ldquo;%w&rdquo;
directive:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>fn <span style=color:#50fa7b>start_doing_something</span>() err {
</span></span><span style=display:flex><span> err <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>do_something</span>()
</span></span><span style=display:flex><span> <span style=color:#ff79c6>if</span> err <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> fmt.<span style=color:#50fa7b>Errorf</span>(<span style=color:#f1fa8c>&#34;I got an error while trying to do something: %w&#34;</span>, err)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=error-chaining-in-rust>Error chaining in Rust<a hidden class=anchor aria-hidden=true href=#error-chaining-in-rust>#</a></h2><p>So now how do we do this in Rust?</p><p>It does not seems there is any built-in way to do this but you can use the
vastly popular crates called <a href=https://crates.io/crates/anyhow><code>anyhow</code></a> for it.</p><p>In this case it&rsquo;s not called wrapping but context (which is a confusing overused
term imho) and here is an example :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> anyhow::Context;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[derive(thiserror::Error, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>pub</span> <span style=color:#ff79c6>enum</span> <span style=color:#50fa7b>MyErr</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>#[error(</span><span style=color:#f1fa8c>&#34;This is the first error&#34;</span><span style=color:#ff79c6>)]</span>
</span></span><span style=display:flex><span>    FirstError,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>#[error(</span><span style=color:#f1fa8c>&#34;This is the middle error&#34;</span><span style=color:#ff79c6>)]</span>
</span></span><span style=display:flex><span>    MidError,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>#[error(</span><span style=color:#f1fa8c>&#34;This is the final error&#34;</span><span style=color:#ff79c6>)]</span>
</span></span><span style=display:flex><span>    FinalError,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>first</span>() -&gt; <span style=color:#50fa7b>anyhow</span>::<span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), MyErr<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Err</span>(MyErr::FirstError)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>second</span>() -&gt; <span style=color:#50fa7b>anyhow</span>::<span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), anyhow::Error<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    first().context(MyErr::MidError)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>finally</span>() -&gt; <span style=color:#50fa7b>anyhow</span>::<span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), anyhow::Error<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    second().context(MyErr::FinalError)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() -&gt; <span style=color:#50fa7b>anyhow</span>::<span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>()<span style=color:#ff79c6>&gt;</span> {
</span></span><span style=display:flex><span>    finally()<span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>We first make our own enum of custom errors.
The enum has a derive on another crates called
<a href=https://crates.io/crates/thiserror><code>thiserror</code></a>. This crates allows you to
have human friendly error message without having to do too much work for it.</p></li><li><p>starting from the bottom on the main function we return and &ldquo;Box&rdquo; all our
errors with <code>anyhow::Results</code> this will get all error to it.</p></li><li><p>We call the <code>finally</code> function with the &ldquo;?&rdquo; operator at the end. It&rsquo;s a
shorthand to say :</p><ul><li>if it&rsquo;s Ok, then yeah please go on and continue do your work.</li><li>if it&rsquo;s not then return the error.</li><li>from the finally function we call another function called second, they are both adding
a context to the error to let the user know where this comes from. This only
happen if we are erroring. If we were Ok() we would not get any error.</li></ul></li></ul><p>The final output will looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>% cargo run -q
</span></span><span style=display:flex><span>Error: This is the final error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Caused by:
</span></span><span style=display:flex><span>    0: This is the middle error
</span></span><span style=display:flex><span>    1: This is the first error
</span></span></code></pre></div><p>with the help of anyhow and thiserror we are nicely showing the chain of errors and what caused it.</p><h2 id=my-humble-comparaison-between-go-and-rust-error-chaining>My humble comparaison between Go and Rust error chaining<a hidden class=anchor aria-hidden=true href=#my-humble-comparaison-between-go-and-rust-error-chaining>#</a></h2><p>The go way is definitely more idiomatic and much easier to write and understand
than the the rust way. However the Rust way is more elegant and I feel
in the long term will be more robust if we have to do some refactoring.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.chmouel.com/>Chmouel's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>