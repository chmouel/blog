<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How does a PUT to a swift object server look like. | Chmouel's blog</title>
<meta name=keywords content="Openstack"><meta name=description content="I have been trying lately to get a better understanding of the Swift code base, and I found the best way to know it was to read it from top to bottom and document it along the way. Here is some of my notes, hopefully more will come.
I am starting with an object PUT when the request is coming from the proxy server. The request in the log-file will look like this :"><meta name=author content><link rel=canonical href=https://blog.chmouel.com/2012/02/06/anatomy-of-a-swift-put-query-to-object-server/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://blog.chmouel.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.chmouel.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.chmouel.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.chmouel.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.chmouel.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.chmouel.com/2012/02/06/anatomy-of-a-swift-put-query-to-object-server/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.chmouel.com/2012/02/06/anatomy-of-a-swift-put-query-to-object-server/"><meta property="og:site_name" content="Chmouel's blog"><meta property="og:title" content="How does a PUT to a swift object server look like."><meta property="og:description" content="I have been trying lately to get a better understanding of the Swift code base, and I found the best way to know it was to read it from top to bottom and document it along the way. Here is some of my notes, hopefully more will come.
I am starting with an object PUT when the request is coming from the proxy server. The request in the log-file will look like this :"><meta property="og:locale" content="en-GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2012-02-06T10:00:33+00:00"><meta property="article:modified_time" content="2012-02-06T10:00:33+00:00"><meta property="article:tag" content="Openstack"><meta name=twitter:card content="summary"><meta name=twitter:title content="How does a PUT to a swift object server look like."><meta name=twitter:description content="I have been trying lately to get a better understanding of the Swift code base, and I found the best way to know it was to read it from top to bottom and document it along the way. Here is some of my notes, hopefully more will come.
I am starting with an object PUT when the request is coming from the proxy server. The request in the log-file will look like this :"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.chmouel.com/posts/"},{"@type":"ListItem","position":2,"name":"How does a PUT to a swift object server look like.","item":"https://blog.chmouel.com/2012/02/06/anatomy-of-a-swift-put-query-to-object-server/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How does a PUT to a swift object server look like.","name":"How does a PUT to a swift object server look like.","description":"I have been trying lately to get a better understanding of the Swift code base, and I found the best way to know it was to read it from top to bottom and document it along the way. Here is some of my notes, hopefully more will come.\nI am starting with an object PUT when the request is coming from the proxy server. The request in the log-file will look like this :\n","keywords":["Openstack"],"articleBody":"I have been trying lately to get a better understanding of the Swift code base, and I found the best way to know it was to read it from top to bottom and document it along the way. Here is some of my notes, hopefully more will come.\nI am starting with an object PUT when the request is coming from the proxy server. The request in the log-file will look like this :\n“PUT /sdb1/2/AUTH_dcbeb7f1271d4374b951954a4f1be15f/foo/file.txt” 201 - “-” “txdw08eca2842e344bb8e11b5869c81cb52” “-” 0.0308\nThe WSGI controller send the request to the method swift.obj.server.ObjectController-\u003ePUT and start to do the following :\nsplits the request.path to : Make sure that partition is mounted. (there is a mount_check option that can toggle this).\nEnsure that there is a X-Timestamp header which should be set by the proxy server.\nStart the check method check_object_creation which does the following :\nMake sure the content_length is not greater than the MAX_FILE_SIZE.\nMake sure there is a content_length header (except if the transfer has been chunked).\nMake sure that there is no content_length (ie: zero byte body) when doing a X-Copy-From.\nMake sure the object_name is not greater than MAX_OBJECT_NAME_LENGTH (1024 bytes by default).\nMaking sure we have a Content-Type in the headers passed (this could be set by the user or auto-guessed via mimetypes.guess_type on the proxy server).\nWhen we have an header of x-object-manifest (for large files support) it makes sure the value is a container/object style and not contain chars like ? \u0026 / in the referenced objects names.\nChecks metadata, make sure at first that the metadata name are not empty.\nThe metadata name length are not greater than MAX_META_NAME_LENGTH (default: 128).\nThe metadata value is not greater than MAX_META_VALUE_LENGTH (default: 256).\nWe don’t have a greater amount of metadatas than MAX_META_COUNT (default: 90).\nThe size of the headers combined (name+value) is not over MAX_META_OVERALL_SIZE (default: 4096).\nIf we have ‘X-Delete-At’ (for the object expiration feature) we are making sure this is not happening in the past or we will exit with an HTTPBadRequest.\nThe class swift.obj.server.DiskFile will be the class that takes care to actually write the file locally. It gets instantiated and do the following in the constructor method:\nIt will hash the following value (account, container, obj) which will become hashed for our example into :\nIt will get the path where this is going to be store which going to be : /srv/node is the devices path which is the configuration directive [proxy]-\u003edevices (default to /srv/node). sdb1 being the mounted device name. add the datadir type, ‘’objects’’ for us. and the partition power (2) last three chars of the hashed name (fe1) the hash itself 46acec4563797178df9ec79b28146fe1 It will get the temporary directory which become in our case to: /srv/node/sdb1/tmp it is basically the devices dir, the device and /tmp If the directory didn’t exists before then it just return. If the directory was existing (already uploaded) then it will parse all files in there and would looks if we have : Files ending up with .ts which will be the tombstone (a deleted file). NB: Replication process will take care to os.unlink() the file properly later. In case of a POST and if we have fast post setting enabled (see config object_post_as_copy in proxy_server) we will detect it and only do a copy of metadata. It calculates the expiration time which is from now + the max_upload_time setting. It start the etag hashing to gradually calculate the md5 of the object. Using the method mkstemp of DiskFile it will start to write to tmpdir, which does the creation of the file like that : Make sure to create the tmpdir. make a secure temporary file (using mkstemp(3)) and yield the file descriptor back to PUT. If there is a content-length in the headers (assigned by the client) it will use the posix function fallocate(2) to pre-allocate that disk space to the file descriptor. It will then iterate over chunk of data size defined by the configuration variable network_chunk_size (default: 64m) reading that chunk from the request wsgi.input : It will update the upload_size value. It will make sure we are not going over our upload expiration time (or get back HTTPRequestTimeout HTTP Error). It will update the calculated md5 with that chunk. It will write the chunk using python os.write For large file sync which is over the configuration variable bytes_per_sync it will do a fdatasync(2) and drop the kernel buffer caches (s_o we are not filling up too much the kernel memory_). if we have a content-length in the client headers that doesn’t match the calculated upload_size we return a 499 Client Disconnected as it means we had a problem somewhere during the upload. It will bail out if we have a etag in the client headers that doesn’t match the calculated etag. And now we are starting defining our metadatas that we are going to store with the file :\nmetadata = {\n_ ‘X-Timestamp’:_ timestamp generated from the proxy_server_._\n_ ‘Content-Type’: d_efined by the user or ‘guessed’ by the proxy server\n_ ‘ETag’:_ calculated value from the request.\n_ ‘Content-Length’:_ an fstat(2) on the file to get the proper value of what is stored on the disk.\n}\nIt will add to the metadata every headers starting by ‘x-object-meta-’. It will add to the metadata the allowed headers to be stored which is defined in the config variable allowed_headers (default: allowed_headers = Content-Disposition, Content-Encoding, X-Delete-At, X-Object-Manifest). It will write the file using the put method of the DiskFile class, which finalise the writing on the file on disk and renames it from the temp file to the real location: It will write the metadata using the xattr(1) feature which is stored directly with the file. If there is a Content-Length with the metada it will drop the kernel cache of that metadata length. It will invalidate the hashes of the datadir directory using the function swift.obj.replicator.invalidate_hashes It will set the hash of the dir as None, which would hint the replication process to have something to do with that dir (and that hash will be generated). This file is stored by partition as python pickle which is in our case: /srv/node/sdb1/objects/2/hashes.pkl Move the file from the tmp dir to go to the datadir. It will use the method unlinkold from DiskFile to remove any older versions of the object file which is any files that has older timestamp. It will start construct the request to make to a containers by going passing the following: account, container, obj as request path. the original headers. the headers Content-Length, Content-Type, X-Timestamp, Etag, X-trans-ID. It will get the headers X-Container-{Host,Partition,Device} from the original headers which is defined by the proxy to know on which container server it going to update. Every different PUT will have assigned a different container to each their own. It will use the async_update method (by self since it’s part of the same class) to make an asynchronous request: Passing the aforementioned build headers and req.path. If the request success (between 200 to 300) it will return to the main (PUT) method. the request didn’t succeed it will create a async_pending file locally in the tmp dir which is going to be picked-up by the replication process to update the container listing when the container is not too busy. When finish it will respond by a HTTPCreated ","wordCount":"1230","inLanguage":"en","datePublished":"2012-02-06T10:00:33Z","dateModified":"2012-02-06T10:00:33Z","author":{"@type":"Person","name":"chmouel"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.chmouel.com/2012/02/06/anatomy-of-a-swift-put-query-to-object-server/"},"publisher":{"@type":"Organization","name":"Chmouel's blog","logo":{"@type":"ImageObject","url":"https://blog.chmouel.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.chmouel.com/ accesskey=h title="Chmouel's blog (Alt + H)">Chmouel's blog</a>
<span class=logo-switches><ul class=lang-switch></ul></span></div><ul id=menu><li><a href=https://photos.chmouel.com title=camera><svg viewBox="0 0 512 512"><title>Photo Website</title><path d="M149.1 64.8 138.7 96H64C28.7 96 0 124.7.0 160V416c0 35.3 28.7 64 64 64H448c35.3.0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H373.3L362.9 64.8C356.4 45.2 338.1 32 317.4 32H194.6c-20.7.0-39 13.2-45.5 32.8zM256 192a96 96 0 110 192 96 96 0 110-192z"/></svg>
<span></span></a></li><li><a href=https://github.com/chmouel/ title=GitHub><svg viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
<span></span></a></li><li><a href=https://fosstodon.org/@chmouel title=Mastodon><svg viewBox="0 0 448 512"><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48.0.0.0-63.72 28.5-63.72 125.7.0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54.0 01-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg>
<span></span></a></li><li><a href=https://redhat.com title=redhat><svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" id="b6bdd2b4-52ab-488a-9a30-1e6d1d7dd2d4" data-name="Layer 1" viewBox="0 0 192.30001 146" sodipodi:docname="logo.svg" width="192.3" height="146" inkscape:version="0.92.5 (2060ec1f9f, 2020-04-08)"><sodipodi:namedview bordercolor="#666666" borderopacity="1" objecttolerance="10" gridtolerance="10" guidetolerance="10" inkscape:pageopacity="0" inkscape:pageshadow="2" inkscape:window-width="1920" inkscape:window-height="1007" id="namedview13" showgrid="false" fit-margin-top="1" fit-margin-right="1" fit-margin-bottom="1" fit-margin-left="1" inkscape:zoom=".45930043" inkscape:cx="306.89999" inkscape:cy="73" inkscape:window-x="0" inkscape:window-y="0" inkscape:window-maximized="1" inkscape:current-layer="b6bdd2b4-52ab-488a-9a30-1e6d1d7dd2d4"/><title>Red Hat</title><path class="a737459c-e8c7-4afa-8008-f6cfd15ccda2" d="m128 84c12.5.0 30.6-2.6 30.6-17.5a19.53 19.53.0 00-.3-3.4L150.9 30.7C149.2 23.6 147.7 20.3 135.2 14.1 125.5 9.1 104.4 1 98.1 1 92.2 1 90.5 8.5 83.6 8.5 76.9 8.5 72 2.9 65.7 2.9c-6 0-9.9 4.1-12.9 12.5.0.0-8.4 23.7-9.5 27.2a6.15 6.15.0 00-.2 1.9C43 53.7 79.3 83.9 128 84m32.5-11.4c1.7 8.2 1.7 9.1 1.7 10.1.0 14-15.7 21.8-36.4 21.8C79 104.5 38.1 77.1 38.1 59a18.35 18.35.0 011.5-7.3C22.8 52.5 1 55.5 1 74.7 1 106.2 75.6 145 134.6 145c45.3.0 56.7-20.5 56.7-36.7.0-12.7-11-27.1-30.8-35.7" id="path8" inkscape:connector-curvature="0"/><path d="m160.5 72.6c1.7 8.2 1.7 9.1 1.7 10.1.0 14-15.7 21.8-36.4 21.8C79 104.5 38.1 77.1 38.1 59a18.35 18.35.0 011.5-7.3l3.7-9.1a6.15 6.15.0 00-.2 1.9c0 9.2 36.3 39.4 84.9 39.4 12.5.0 30.6-2.6 30.6-17.5A19.53 19.53.0 00158.3 63z" id="path10" inkscape:connector-curvature="0"/></svg>
<span></span></a></li><li><a href=https://app.strava.com/athletes/126695 title=Strava><svg viewBox="0 0 384 512"><path d="M158.4.0 7 292h89.2l62.2-116.1L220.1 292h88.5zm150.2 292-43.9 88.2-44.6-88.2h-67.6l112.2 220 111.5-220z"/></svg>
<span></span></a></li><li><a href=https://twitter.com/chmouel title=Twitter><svg viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
<span></span></a></li><li><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">How does a PUT to a swift object server look like.</h1><div class=post-meta><span title='2012-02-06 10:00:33 +0000 UTC'>February 6, 2012</span>&nbsp;|&nbsp;<a href=https://github.com/chmouel/blog/tree/main/content/posts/2012-02-06-anatomy-of-a-swift-put-query-to-object-server.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=post-content><p>I have been trying lately to get a better understanding of the Swift code base, and I found the best way to know it was to read it from top to bottom and document it along the way. Here is some of my notes, hopefully more will come.</p><p>I am starting with an object <strong>PUT</strong> when the request is coming from the proxy server. The request in the log-file will look like this :</p><p><em>&ldquo;PUT /sdb1/2/AUTH_dcbeb7f1271d4374b951954a4f1be15f/foo/file.txt&rdquo; 201 - &ldquo;-&rdquo; &ldquo;txdw08eca2842e344bb8e11b5869c81cb52&rdquo; &ldquo;-&rdquo; 0.0308</em></p><p>The WSGI controller send the request to the method <a href=https://github.com/openstack/swift/blob/80a3cb556d1ea2b8ac284816096198b89a2cf117/swift/obj/server.py#L530>swift.obj.server.ObjectController->PUT</a> and start to do the following :</p><ul><li>splits the request.path to :</li></ul><ul><li><p>Make sure that partition is mounted. (<em>there is a <strong>mount_check</strong> option that can toggle this</em>).</p></li><li><p>Ensure that there is a X-Timestamp header which should be set by the proxy server.</p></li><li><p>Start the check method <a href=https://github.com/openstack/swift/blob/80a3cb556d1ea2b8ac284816096198b89a2cf117/swift/common/constraints.py#L85>check_object_creation</a> which does the following :</p></li><li><p>Make sure the <strong>content_length</strong> is not greater than the <strong>MAX_FILE_SIZE</strong>.</p></li><li><p>Make sure there is a <strong>content_length</strong> header (<em>except if the transfer has been chunked</em>).</p></li><li><p>Make sure that there is no <strong>content_length</strong> (ie: zero byte body) when doing a <strong>X-Copy-From</strong>.</p></li><li><p>Make sure the <strong>object_name</strong> is not greater than <strong>MAX_OBJECT_NAME_LENGTH</strong> (<em>1024 bytes by default</em>).</p></li><li><p>Making sure we have a <strong>Content-Type</strong> in the headers passed (this could be set by the user or auto-guessed via <a href=http://docs.python.org/library/mimetypes.html#mimetypes.guess_type>mimetypes.guess_type</a> on the proxy server).</p></li><li><p>When we have an header of <strong>x-object-manifest</strong> (<em>for large files support</em>) it makes sure the value is a container/object style and not contain chars like <strong>? & /</strong> in the referenced objects names.</p></li><li><p>Checks metadata, make sure at first that the metadata name are not empty.</p></li><li><p>The metadata name length are not greater than <strong>MAX_META_NAME_LENGTH</strong> (<em>default: 128</em>).</p></li><li><p>The metadata value is not greater than <strong>MAX_META_VALUE_LENGTH</strong> (<em>default: 256</em>).</p></li><li><p>We don&rsquo;t have a greater amount of metadatas than <strong>MAX_META_COUNT</strong> (<em>default: 90</em>).</p></li><li><p>The size of the headers combined (<em>name+value</em>) is not over <strong>MAX_META_OVERALL_SIZE</strong> (<em>default: 4096</em>).</p></li><li><p>If we have &lsquo;<strong>X-Delete-At</strong>&rsquo; (<em>for the object expiration feature</em>) we are making sure this is not happening in the past or we will exit with an <strong>HTTPBadRequest</strong>.</p></li><li><p>The class <a href=https://github.com/openstack/swift/blob/80a3cb556d1ea2b8ac284816096198b89a2cf117/swift/obj/server.py#L94>swift.obj.server.DiskFile</a> will be the class that takes care to actually write the file locally. It gets instantiated and do the following in the constructor method:</p></li><li><p>It will hash the following  value (<strong>account</strong>, <strong>container</strong>, <strong>obj)</strong> which will become hashed for our example into :</p></li></ul><ul><li>It will get the path where this is going to be store which going to be :</li></ul><ul><li><strong>/srv/node</strong> is the devices path which is the configuration directive <a href=https://github.com/openstack/swift/blob/master/etc/object-server.conf-sample#L8>[proxy]->devices</a> (<em>default to /srv/node</em>).</li><li><strong>sdb1</strong> being the mounted device name.</li><li>add the datadir type, &lsquo;&rsquo;<strong>objects</strong>&rsquo;&rsquo; for us.</li><li>and the partition power (<strong>2</strong>)</li><li>last three chars of the hashed name (<strong>fe1</strong>)</li><li>the hash itself <strong>46acec4563797178df9ec79b28146fe1</strong></li><li>It will get the temporary directory which become in our case to: <strong>/srv/node/sdb1/tmp</strong> it is basically the devices dir, the device and /tmp</li><li>If the directory didn&rsquo;t exists before then it just return.</li><li>If the directory was existing (already uploaded) then it will parse all files in there and would looks if we have :</li><li>Files ending up with .<strong><em>ts</em></strong>  which will be the tombstone (a deleted file).  NB: <em>Replication process will take care to os.unlink() the file properly later.</em></li><li>In case of a <em>POST</em> and if we have fast post setting enabled (see config <strong>object_post_as_copy</strong> in proxy_server) we will detect it and only do a copy of metadata.</li><li>It calculates the expiration time which is from now + the <strong>max_upload_time</strong> setting.</li><li>It start the etag hashing to gradually calculate the md5 of the object.</li><li> Using the method <strong>mkstemp</strong> of <strong>DiskFile</strong> it will start to write to tmpdir, which does the creation of the file like that :</li><li>Make sure to create the <em>tmpdir</em>.</li><li>make a secure temporary file (using <strong>mkstemp</strong>(3)) and yield the file descriptor back to <strong>PUT</strong>.</li><li>If there is a <strong>content-length</strong> in the headers (assigned by the client) it will use the posix function <strong><a href=http://linux.die.net/man/2/fallocate>fallocate</a></strong>(2) to pre-allocate that disk space to the file descriptor.</li><li>It will then iterate over chunk of data size defined by the configuration variable <strong>network_chunk_size</strong> (<em>default: 64m</em>) reading that chunk from the request <em>wsgi.input</em> :</li><li>It will update the <strong>upload_size</strong> value.</li><li>It will make sure we are not going over our upload expiration time (<em>or get back <strong>HTTPRequestTimeout</strong> HTTP Error</em>).</li><li>It will update the calculated md5 with that chunk.</li><li>It will write the chunk using python <a href=http://docs.python.org/library/os.html#os.write>os.write</a></li><li>For large file sync which is over the configuration variable <strong>bytes_per_sync</strong> it will do a <a href=http://linux.die.net/man/2/fdatasync>fdatasync</a>(2) and drop the kernel buffer caches (s_o we are not filling up too much the kernel memory_).</li><li>if we have a <strong>content-length</strong> in the client headers that doesn&rsquo;t match the calculated <strong>upload_size</strong> we return a <strong><em>499 Client Disconnected</em></strong> as it means we had a problem somewhere during the upload.</li><li>It will bail out if we have a etag in the client headers that doesn&rsquo;t match the calculated etag.</li></ul><p>And now we are starting defining our metadatas that we are going to store with the file  :</p><blockquote><p><em>metadata = {</em><br>_  &lsquo;<strong>X-Timestamp&rsquo;</strong>:_ timestamp generated from the proxy_server_._<br>_  &lsquo;<strong>Content-Type</strong>&rsquo;: d_efined by the user or &lsquo;guessed&rsquo; by the proxy server<br>_  &lsquo;<strong>ETag</strong>&rsquo;:_ calculated value from the request.<br>_  &lsquo;<strong>Content</strong>-<strong>Length</strong>&rsquo;:_ an fstat(2) on the file to get the proper value of what is stored on the disk.<br><em>}</em></p></blockquote><ul><li>It will add to the metadata every headers starting by <strong>&lsquo;x-object-meta-&rsquo;.</strong></li><li>It will add to the metadata the allowed headers to be stored which is defined in the config variable <strong>allowed_headers</strong> (default: <em>allowed_headers = Content-Disposition, Content-Encoding, X-Delete-At, X-Object-Manifest</em>).</li><li>It will write the file using the put method of the DiskFile class, which finalise the writing on the file on disk and renames it from the temp file to the real location:</li><li>It will write the metadata using the <a href=https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/xattr.1.html>xattr</a>(1) feature which is stored directly with the file.</li><li>If there is a <strong>Content-Length</strong> with the metada it will drop the kernel cache of that metadata length.</li><li>It will invalidate the hashes of the <strong>datadir</strong> directory using the function <a href=https://github.com/openstack/swift/blob/80a3cb556d1ea2b8ac284816096198b89a2cf117/swift/obj/replicator.py#L128>swift.obj.replicator.invalidate_hashes</a></li><li>It will set the hash of the dir as <strong>None</strong>, which would hint the replication process to have something to do with that dir (and that hash will be generated).</li><li>This file is stored by partition as python <a href=http://docs.python.org/library/pickle.html>pickle</a> which is in our case: <em>/srv/node/sdb1/objects/2/hashes.pkl</em></li><li>Move the file from the tmp dir to go to the <strong>datadir</strong>.</li><li>It will use the method <a href=https://github.com/openstack/swift/blob/master/swift/obj/server.py#L283>unlinkold</a> from <strong>DiskFile</strong> to remove any older versions of the object file which is any files that has older timestamp.</li><li>It will start construct the request to make to a containers by going passing the following:</li><li><strong>account</strong>, <strong>container</strong>, <strong>obj</strong> as request path.</li><li>the original headers.</li><li>the headers <strong>Content-Length</strong>, <strong>Content-Type</strong>, <strong>X-Timestamp</strong>, <strong>Etag</strong>, <strong>X-trans-ID</strong>.</li><li>It will get the headers <strong>X-Container-{Host,Partition,Device}</strong> from the original headers which is defined by the proxy to know on which container server it going to update. Every different PUT will have assigned a different container to each their own.</li><li>It will use the <a href=https://github.com/openstack/swift/blob/80a3cb556d1ea2b8ac284816096198b89a2cf117/swift/obj/server.py#L381>async_update</a> method (<em>by self since it&rsquo;s part of the same class</em>) to make an asynchronous request:</li><li>Passing the aforementioned build headers and req.path.</li><li> If the request success (between <strong>200</strong> to <strong>300</strong>) it will return to the main (<strong>PUT</strong>) method.</li><li> the request didn&rsquo;t succeed it will create a <strong>async_pending</strong> file locally in the tmp dir which is going to be picked-up by the replication process to update the container listing when the container is not too busy.</li><li>When finish it will respond by a <strong>HTTPCreated</strong></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.chmouel.com/tags/openstack/>Openstack</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.chmouel.com/>Chmouel's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>